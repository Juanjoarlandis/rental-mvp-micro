--- auth/requirements.txt ---
fastapi==0.116.0
uvicorn==0.35.0

pydantic==2.11.7
pydantic-core==2.33.2
pydantic-settings==2.10.1

SQLAlchemy==2.0.41
psycopg2-binary==2.9.6

python-jose[cryptography]==3.5.0
passlib==1.7.4
bcrypt==3.2.2
python-multipart==0.0.6
python-dotenv==1.1.1

# rate‑limit
slowapi==0.1.8

# extras (rendimiento opc.)
uvloop==0.21.0
httptools==0.6.4
email-validator==2.1.1
alembic==1.16.4
pytest==8.2.0
pytest-cov==5.0.0

--- auth/.env ---
# services/auth/.env
DATABASE_URL=postgresql+psycopg2://auth_user:auth_pass@auth-db:5432/auth
SECRET_KEY=SuperClaveUltraSecreta
FRONTEND_URL=http://frontend

--- auth/Dockerfile ---
### ───────────────────────── build stage ─────────────────────────
FROM python:3.12-slim AS base

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# Herramientas y headers para compilar wheels (psycopg2, bcrypt, etc.)
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    build-essential \
    libffi-dev \
    libpq-dev \          
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt


### ───────────────────────── runtime stage ───────────────────────
#  Contenedor final ► sin root  +  sólo dependencias runtime
FROM python:3.12-slim

# 1️⃣  libpq5 *runtime* – lo mínimo para que psycopg2 funcione
RUN apt-get update \
    && apt-get install -y --no-install-recommends libpq5 \
    && rm -rf /var/lib/apt/lists/*

# 2️⃣  Copiamos todo lo instalado por pip en el stage base
COPY --from=base /usr/local /usr/local

WORKDIR /app
ENV PYTHONPATH=/app

# 3️⃣  Creamos un usuario no-root y lo usamos
RUN adduser --disabled-password --gecos '' appuser
USER appuser

# 4️⃣  Código y configuración
COPY --chown=appuser:appuser app/          ./app
COPY --chown=appuser:appuser migrations/   ./migrations
COPY --chown=appuser:appuser alembic.ini   .
COPY --chown=appuser:appuser .env          .

EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]


--- auth/alembic.ini ---
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = migrations

# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library that can be
# installed by adding `alembic[tz]` to the pip requirements
# string value is passed to dateutil.tz.gettz()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# alembic.ini
sqlalchemy.url = postgresql+psycopg2://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}



[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


--- auth/migrations/script.py.mako ---
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}


--- auth/migrations/README ---
Generic single-database configuration.

--- auth/migrations/env.py ---
# migrations/env.py
"""Alembic migration environment for the Auth service."""

from __future__ import annotations

from logging.config import fileConfig

from alembic import context
from sqlalchemy import engine_from_config, pool

# ────────────────────────────────────────────────────────
# 1. Configuración y logging
# ────────────────────────────────────────────────────────
config = context.config
fileConfig(config.config_file_name)

# ────────────────────────────────────────────────────────
# 2. Metadata de modelos  → autogenerate
# ────────────────────────────────────────────────────────
from app.models.models import Base  # importa las tablas
target_metadata = Base.metadata

# (opcional, pero aconsejado: convenciones de nombres)
target_metadata.naming_convention = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s",
}

# ────────────────────────────────────────────────────────
# 3. URL de conexión: utiliza la misma que tu servicio
# ────────────────────────────────────────────────────────
from app.core.config import settings  # noqa: E402

config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

# ────────────────────────────────────────────────────────
# 4. Hooks offline / online
# ────────────────────────────────────────────────────────
def run_migrations_offline() -> None:
    """Genera SQL sin tocar la BD (alembic upgrade --sql)."""
    context.configure(
        url=config.get_main_option("sqlalchemy.url"),
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
        compare_server_default=True,
    )
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Aplica las migraciones sobre la BD."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True,
            compare_server_default=True,
        )
        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


--- auth/migrations/versions/20250712_init.py ---
"""tabla users inicial

Revision ID: 20250712_init
Revises:
Create Date: 2025-07-12 00:00:00
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = "20250712_init"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "users",
        sa.Column("id", sa.Integer(), primary_key=True, nullable=False),
        sa.Column("username", sa.String(), nullable=False),
        sa.Column("email", sa.String(), nullable=False),
        sa.Column("hashed_pw", sa.String(), nullable=False),
        sa.UniqueConstraint("username"),
        sa.UniqueConstraint("email"),
    )
    op.create_index("ix_users_username", "users", ["username"])
    op.create_index("ix_users_email", "users", ["email"])


def downgrade() -> None:
    op.drop_index("ix_users_email", table_name="users")
    op.drop_index("ix_users_username", table_name="users")
    op.drop_table("users")


--- auth/app/main.py ---
# services/auth/app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware  # MODIFIED: Importado para CORS
from slowapi import _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded

from app.api import auth, health, password          # ← nuevos routers
from app.core.ratelimit import limiter
from app.models.database import Base, engine
import app.models.models        # noqa: F401  (importa tablas)

from app.core.config import settings  # MODIFIED: Para orígenes CORS

app = FastAPI(
    title="rental‑mvp – Auth Service",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi/v1.json",   # ← OpenAPI versionada
)

# MODIFIED: Añadir CORS middleware (best practice: orígenes específicos)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[settings.FRONTEND_URL],  # De .env o config
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ─────────── BD auto‑create (solo dev) ───────────
@app.on_event("startup")
def _init_db() -> None:
    Base.metadata.create_all(bind=engine)

# ─────────── Rate‑limit global handler ───────────
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# ─────────── Rutas ───────────
app.include_router(auth.router,     prefix="/api/auth")
app.include_router(password.router, prefix="/api/auth")
app.include_router(health.router)   # /health a raíz

--- auth/app/__init__.py ---


--- auth/app/deps.py ---
# services/auth/app/deps.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from sqlalchemy.orm import Session

from app.models.database import SessionLocal
from app.core.config import settings
from app.crud import user as crud
from app.schemas.user import UserOut

# ──────────── DB session ────────────
def get_db() -> Session:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ──────────── Auth helper ───────────
oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="/api/auth/token"   # el prefijo '/api/auth' se añade en main.py
)


def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db),
) -> UserOut:
    """
    Valida el JWT y devuelve el usuario asociado.
    Lanza 401 si es inválido o no existe.
    """
    # MODIFIED: Mejora - Añadido manejo de expiración y scopes si aplica
    cred_exc = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Credenciales no válidas",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str | None = payload.get("sub")
        if not username:
            raise cred_exc
    except JWTError as e:  # MODIFIED: Más granular (expirado, inválido)
        detail = "Token expirado" if "exp" in str(e) else "Token inválido"
        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail)

    user = crud.get_user_by_username(db, username)
    if not user:
        raise cred_exc
    return user

--- auth/app/models/models.py ---
from sqlalchemy import Column, Integer, String
from app.models.database import Base   # usa SIEMPRE la misma Base

class User(Base):
    __tablename__ = "users"
    id        = Column(Integer, primary_key=True)
    username  = Column(String, unique=True, index=True, nullable=False)
    email     = Column(String, unique=True, index=True, nullable=False)
    hashed_pw = Column(String, nullable=False)


--- auth/app/models/__init__.py ---


--- auth/app/models/database.py ---
# services/auth/app/models/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

connect_args = {"check_same_thread": False} if settings.DATABASE_URL.startswith("sqlite") else {}

engine = create_engine(
    settings.DATABASE_URL,
    connect_args=connect_args,
    echo=True,
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


--- auth/app/schemas/token.py ---
# app/schemas/token.py
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"


--- auth/app/schemas/__init__.py ---
from .user import UserCreate, UserOut  # noqa: F401

__all__ = ["UserCreate", "UserOut"]


--- auth/app/schemas/user.py ---
from pydantic import BaseModel, EmailStr, ConfigDict

class UserCreate(BaseModel):
    username: str
    email: EmailStr
    password: str


class UserOut(BaseModel):
    id: int
    username: str
    email: EmailStr

    model_config = ConfigDict(from_attributes=True)  # ← en vez del viejo Config


--- auth/app/crud/__init__.py ---
# services/auth/app/crud/__init__.py
from .user import (
    get_user_by_username,
    get_user_by_email,
    create_user,
    verify_password,
)

__all__ = [
    "get_user_by_username",
    "get_user_by_email",
    "create_user",
    "verify_password",
]


--- auth/app/crud/user.py ---
# app/crud/user.py
from __future__ import annotations

import bcrypt
from passlib.context import CryptContext
from sqlalchemy.orm import Session

from app.models.models import User
from app.schemas.user import UserCreate

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ───────────────────────── helpers privados ──────────────────────────────


def _hash_password(pwd: str) -> str:
    """Devuelve el hash seguro de *pwd* usando passlib/bcrypt."""
    return pwd_context.hash(pwd)


# ────────────────────────────── Lectura ───────────────────────────────────


def get_user_by_username(db: Session, username: str) -> User | None:
    """Busca un usuario por *username* (o None si no existe)."""
    return db.query(User).filter(User.username == username).first()


def get_user_by_email(db: Session, email: str) -> User | None:
    """Busca un usuario por email (o None si no existe)."""
    return db.query(User).filter(User.email == email).first()


# ───────────────────────────── Escritura ──────────────────────────────────


def create_user(db: Session, user_in: UserCreate) -> User:
    """
    Crea un nuevo usuario con contraseña hasheada y lo devuelve.
    Lanza IntegrityError si el username/email ya existen.
    """
    db_user = User(
        username=user_in.username,
        email=user_in.email,
        hashed_pw=_hash_password(user_in.password),
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


# ──────────────────────── Utilidades varias ──────────────────────────────


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Comprueba que *plain_password* coincide con el hash almacenado.
    Se usa bcrypt directamente para evitar dependencias implícitas.
    """
    try:
        return bcrypt.checkpw(plain_password.encode(), hashed_password.encode())
    except Exception:  # noqa: BLE001
        # bcrypt lanza ValueError si el hash no es válido
        return False


--- auth/app/core/ratelimit.py ---
from slowapi import Limiter
from slowapi.util import get_remote_address

# instancia única que compartirán todos los routers
# MODIFIED: Auditado - límites más estrictos para prevenir abuso
limiter = Limiter(key_func=get_remote_address, default_limits=["100/minute"])  # Límite global por IP

--- auth/app/core/__init__.py ---


--- auth/app/core/config.py ---
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    FRONTEND_URL: str | None = None  # MODIFIED: Optional
    DATABASE_URL: str
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

settings = Settings()        # instancia global


--- auth/app/core/security.py ---
# services/auth/app/core/security.py
from datetime import datetime, timedelta
from jose import jwt, JWTError

from app.core.config import settings

# ───────── JWT genérico ──────────────────────────────────────────
def _encode(payload: dict, minutes: int) -> str:
    exp = datetime.utcnow() + timedelta(minutes=minutes)
    payload.update({"exp": exp})
    return jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


# ───────── Access token (igual) ─────────────────────────────────
def create_access_token(subject: str) -> str:
    return _encode({"sub": subject}, settings.ACCESS_TOKEN_EXPIRE_MINUTES)


# ───────── Reset‑password token ────────────────────────────────
RESET_TOKEN_MINUTES = 15     # caduca rápido

def create_reset_token(username: str) -> str:
    return _encode({"sub": username, "scope": "pwd_reset"}, RESET_TOKEN_MINUTES)


def verify_reset_token(token: str) -> str | None:
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        if payload.get("scope") != "pwd_reset":
            return None
        return payload.get("sub")
    except JWTError:
        return None


--- auth/app/api/password.py ---
# services/auth/app/api/password.py
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    Request,      # 👈 necesario para slowapi
    status,
)
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session

from app.deps import get_db
from app.core.security import create_reset_token, verify_reset_token
from app.crud import user as crud
from app.core.ratelimit import limiter

router = APIRouter(tags=["password"])

# ───────── forgotten ────────────────────────────────────────────
class ForgotIn(BaseModel):
    username: str = Field(..., min_length=3)


class ForgotOut(BaseModel):
    reset_token: str


@router.post("/password/forgot", response_model=ForgotOut)
@limiter.limit("3/minute")
def forgot(
    request: Request,           # 👈 obligatorio
    data: ForgotIn,
    db: Session = Depends(get_db),
):
    user = crud.get_user_by_username(db, data.username)
    if not user:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Usuario no encontrado")
    token = create_reset_token(user.username)
    # MVP → devolvemos el token; en prod se enviaría por email
    return {"reset_token": token}


# ───────── reset ────────────────────────────────────────────────
class ResetIn(BaseModel):
    token: str
    new_password: str = Field(..., min_length=8)


@router.post("/password/reset", status_code=status.HTTP_204_NO_CONTENT)
@limiter.limit("3/minute")
def reset(
    request: Request,           # 👈 obligatorio
    data: ResetIn,
    db: Session = Depends(get_db),
):
    username = verify_reset_token(data.token)
    if not username:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Token inválido o expirado")

    user = crud.get_user_by_username(db, username)
    if not user:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Usuario no encontrado")

    # actualiza hash
    user.hashed_pw = crud.pwd_context.hash(data.new_password)
    db.commit()


--- auth/app/api/health.py ---
# services/auth/app/api/health.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import text            # 👈🏻 NEW

from app.deps import get_db

router = APIRouter(tags=["health"])

@router.get("/health", summary="Lightweight liveness & DB check")
def health(db: Session = Depends(get_db)):
    try:
        # SQLAlchemy 2.0 exige usar text() para SQL literal
        db.execute(text("SELECT 1"))   # 👈🏻 FIX
        db_status = "ok"
    except SQLAlchemyError:
        db_status = "error"
    return {"ok": True, "db": db_status}


--- auth/app/api/auth.py ---
# services/auth/app/api/auth.py   ← versión completa ⚡️
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    Request,          # 👈 necesario para slowapi
    status,
)
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session

from app.deps import get_db, get_current_user
from app.crud import user as crud
from app.schemas.user import UserCreate, UserOut
from app.schemas.token import Token
from app.core.security import create_access_token
from app.core.ratelimit import limiter                 # 🆕

router = APIRouter(tags=["auth"])                      # (sin prefix aquí)

# ─────────────────────────── SIGN-UP ────────────────────────────
@router.post(
    "/signup",
    response_model=UserOut,
    status_code=status.HTTP_201_CREATED,
)
@limiter.limit("5/minute")                             # 🆕 rate-limit
def signup(
    request: Request,               # 👈 obligatorio para slowapi
    user_in: UserCreate,
    db: Session = Depends(get_db),
):
    """
    Registra un nuevo usuario.

    • 409 si el **username** o el **email** ya existen.
    """
    try:
        return crud.create_user(db, user_in)
    except IntegrityError:
        db.rollback()
        detail = (
            "Nombre de usuario en uso"
            if crud.get_user_by_username(db, user_in.username)
            else "Email ya registrado"
        )
        raise HTTPException(status.HTTP_409_CONFLICT, detail=detail)


# ─────────────────────────── LOGIN ──────────────────────────────
@router.post("/token", response_model=Token)
@limiter.limit("10/minute")                            # 🆕 rate-limit
def login_for_access_token(
    request: Request,               # 👈 obligatorio
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db),
):
    """
    Intercambia usuario/contraseña por un JWT (password grant).

    • 401 si las credenciales no son válidas.
    """
    user = crud.get_user_by_username(db, form_data.username)
    if not user or not crud.verify_password(form_data.password, user.hashed_pw):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuario o contraseña incorrectos",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token = create_access_token(subject=user.username)
    return {"access_token": access_token, "token_type": "bearer"}


# ─────────────────────────── WHO AM I? ──────────────────────────
@router.get("/users/me", response_model=UserOut)
def read_users_me(current_user: UserOut = Depends(get_current_user)):
    """Devuelve **id, username y email** asociados al token actual."""
    return current_user


# alias corto opcional
router.get("/me", response_model=UserOut)(read_users_me)


--- auth/app/api/__init__.py ---
from . import auth, health, password   # re‑export para main.py

__all__ = ["auth", "health", "password"]


--- auth/tests/test_health.py ---
def test_health_ok(client):
    """El health‑check debe estar vivo y con la BD operativa."""
    resp = client.get("/health")
    assert resp.status_code == 200
    assert resp.json() == {"ok": True, "db": "ok"}


--- auth/tests/test_rate_limit.py ---
from app.core.ratelimit import limiter

def test_rate_limit_on_signup(client):
    """
    Reactivamos temporalmente el limiter y superamos el umbral 5/min → 429.
    """
    limiter.enabled = True   # 🔛

    payload = {
        "email":    "rate@test.com",
        "password": "Pass12345",
    }
    # 5 peticiones permitidas
    for i in range(5):
        client.post("/api/auth/signup", json={**payload, "username": f"user{i}"})

    # 6ª → debería saltar el límite
    r_exceed = client.post("/api/auth/signup", json={**payload, "username": "user_exceed"})
    assert r_exceed.status_code == 429

    limiter.enabled = False  # 🔚  para no interferir con otros tests


--- auth/tests/test_auth_flow.py ---
from uuid import uuid4


def test_signup_login_me_flow(client):
    """Flujo feliz: alta → login → /me."""
    # 1️⃣  Alta de usuario
    uname = f"user_{uuid4().hex[:8]}"
    payload = {
        "username": uname,
        "email": f"{uname}@example.com",
        "password": "SuperPass123",
    }
    r_signup = client.post("/api/auth/signup", json=payload)
    assert r_signup.status_code == 201

    # 2️⃣  Alta duplicada → 409
    r_dup = client.post("/api/auth/signup", json=payload)
    assert r_dup.status_code == 409

    # 3️⃣  Login OK
    r_token = client.post(
        "/api/auth/token",
        data={"username": uname, "password": payload["password"]},
    )
    assert r_token.status_code == 200
    token = r_token.json()["access_token"]

    # 4️⃣  /me con Bearer
    headers = {"Authorization": f"Bearer {token}"}
    r_me = client.get("/api/auth/me", headers=headers)
    assert r_me.status_code == 200
    me = r_me.json()
    assert me["username"] == uname
    assert me["email"] == payload["email"]

    # 5️⃣  Login con pass incorrecto → 401
    r_bad = client.post(
        "/api/auth/token",
        data={"username": uname, "password": "wrong"},
    )
    assert r_bad.status_code == 401


--- auth/tests/conftest.py ---
"""
Fixtures globales para los tests del micro‑servicio Auth
– BD SQLite in‑memory compartida
– Override de get_db
– TestClient
"""

from __future__ import annotations

import os
import sys
from pathlib import Path
from typing import Generator

# ────── variables de entorno (antes de importar la app) ──────
os.environ["DATABASE_URL"] = "sqlite+pysqlite:///:memory:"
os.environ.setdefault("SECRET_KEY", "TEST_SECRET")

# ────── añadir services/auth al PYTHONPATH del runner ──────
PROJECT_ROOT = Path(__file__).resolve().parents[2]          # rental-mvp-micro/
AUTH_PATH = PROJECT_ROOT / "services" / "auth"
sys.path.insert(0, str(AUTH_PATH)) if str(AUTH_PATH) not in sys.path else None

# ────── imports de la app (ya con env preparado) ──────
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool                     #  ⭐️

from app.main import app
from app.deps import get_db
from app.core.ratelimit import limiter
from app.models.database import Base

# ────── motor y sesión para la BD de pruebas ──────
engine = create_engine(
    os.environ["DATABASE_URL"],
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,            #  👈 comparte la misma conexión
)
TestingSessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)

Base.metadata.create_all(bind=engine)       # crea todas las tablas una vez


def override_get_db() -> Generator:
    db = TestingSessionLocal()
    try:
        yield db
        db.commit()
    finally:
        db.close()


# sustituimos la dependencia real por la de pruebas
app.dependency_overrides[get_db] = override_get_db
limiter.enabled = False        # sin límites en los tests excepto cuando se active explícitamente


# ────── cliente de prueba para cada test ──────
@pytest.fixture()
def client() -> Generator[TestClient, None, None]:
    with TestClient(app) as c:
        yield c


--- auth/tests/test_password_flow.py ---
from uuid import uuid4

def test_password_reset_flow(client):
    """Genera reset_token, restablece contraseña y verifica login."""
    # 1️⃣  Alta
    uname = f"user_{uuid4().hex[:8]}"
    client.post(
        "/api/auth/signup",
        json={"username": uname, "email": f"{uname}@mail.com", "password": "OldPass123"},
    )

    # 2️⃣  Obtener reset_token
    r_forgot = client.post("/api/auth/password/forgot", json={"username": uname})
    assert r_forgot.status_code == 200
    reset_token = r_forgot.json()["reset_token"]

    # 3️⃣  Reset OK
    r_reset = client.post(
        "/api/auth/password/reset",
        json={"token": reset_token, "new_password": "NewPass456"},
    )
    assert r_reset.status_code == 204

    # 4️⃣  Login con nueva contraseña
    r_login_new = client.post(
        "/api/auth/token",
        data={"username": uname, "password": "NewPass456"},
    )
    assert r_login_new.status_code == 200

    # 5️⃣  Login con contraseña antigua debe fallar
    r_login_old = client.post(
        "/api/auth/token",
        data={"username": uname, "password": "OldPass123"},
    )
    assert r_login_old.status_code == 401



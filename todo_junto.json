{
    "catalog/requirements.txt": "\nfastapi==0.116.0\nuvicorn==0.35.0\npydantic==2.11.7\npydantic-core==2.33.2\npydantic-settings==2.10.1\nSQLAlchemy==2.0.41\npython-jose[cryptography]==3.5.0\npython-multipart==0.0.6\npython-dotenv==1.1.1\nalembic==1.16.4\nemail-validator==2.1.1     # (pydantic extra)\nuvloop==0.21.0\nhttptools==0.6.4\npsycopg2-binary==2.9.9 ",
    "catalog/.env": "\nDATABASE_URL=postgresql+psycopg2://catalog_user:catalog_pass@catalog-db:5432/catalog\nSECRET_KEY=SuperClaveUltraSecreta\nFRONTEND_URL=http://frontend",
    "catalog/Dockerfile": "FROM python:3.12-slim\n\nRUN apt-get update \\\n    && apt-get install -y --no-install-recommends libffi-dev build-essential libpq-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /app\nENV PYTHONPATH=/app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# código + alembic + env\nCOPY app/         ./app\nCOPY alembic.ini  .\nCOPY migrations/  ./migrations\nCOPY .env         .\n\nEXPOSE 8000\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n",
    "catalog/test_endpoints.sh": "#!/usr/bin/env bash\nset -euo pipefail\nIFS=$'\\n\\t'\n\nAUTH=http://localhost:8001/api/auth\nCAT=http://localhost:8002/api\nUSERNAME=demo; EMAIL=demo@example.com; PASSWORD=demo\n\nj() { jq -C .; }            # pretty-json coloreado\nauth() { curl -s \"$@\" \"${AUTHZ[@]}\"; }\n\necho \"────────── 1) SIGN-UP ──────────\"\ncurl -s -X POST \"$AUTH/signup\" \\\n     -H 'Content-Type: application/json' \\\n     -d \"{\\\"username\\\":\\\"$USERNAME\\\",\\\"email\\\":\\\"$EMAIL\\\",\\\"password\\\":\\\"$PASSWORD\\\"}\" \\\n  | j || echo \"(usuario ya existe)\"\n\necho \"────────── 2) LOGIN ────────────\"\nTOKEN=$(curl -s -X POST \"$AUTH/token\" \\\n              -H 'Content-Type: application/x-www-form-urlencoded' \\\n              -d \"username=$USERNAME&password=$PASSWORD\" \\\n        | jq -r .access_token)\nAUTHZ=(-H \"Authorization: Bearer $TOKEN\")\necho \"JWT => $TOKEN\"\n\necho \"────────── 3) /me ──────────────\"\n# Detecta cuál de los dos paths expone el servicio\nfor ME in \"$AUTH/me\" \"$AUTH/users/me\"; do\n  CODE=$(curl -s -o /dev/null -w '%{http_code}' \"$ME\" \"${AUTHZ[@]}\")\n  [[ $CODE == 200 ]] && { curl -s \"$ME\" \"${AUTHZ[@]}\" | j; break; }\ndone\n\necho \"────────── 4) CATEGORIES ───────\"\ndeclare -A CIDs\nfor NAME in \"Herramientas\" \"Decoración\"; do\n  # ¿existe ya?\n  CID=$(curl -s \"$CAT/categories/\" | jq \".[] | select(.name==\\\"$NAME\\\") | .id\")\n  if [[ -z $CID ]]; then\n     CID=$(curl -s -X POST \"$CAT/categories/\" \"${AUTHZ[@]}\" \\\n                 -H 'Content-Type: application/json' \\\n                 -d \"{\\\"name\\\":\\\"$NAME\\\"}\" | jq -r .id)\n  fi\n  CIDs[$NAME]=$CID\n  echo \"• $NAME id=${CID}\"\ndone\n\necho \"────────── 5) ITEMS CRUD ───────\"\nDATA='{\n  \"name\":\"Taladro Bosch\",\n  \"description\":\"800 W\",\n  \"price_per_h\":4.5,\n  \"image_urls\":[\"https://picsum.photos/seed/taladro/800/600\"]\n}'\n# Sólo enviamos categories si tenemos IDs válidos\n[[ -n ${CIDs[Herramientas]} ]] && \\\n  DATA=$(jq --argjson cid ${CIDs[Herramientas]} '. + {categories:[$cid]}' <<<\"$DATA\")\n\nITEM=$(curl -s -X POST \"$CAT/items/\" \"${AUTHZ[@]}\" \\\n            -H 'Content-Type: application/json' \\\n            -d \"$DATA\")\necho \"$ITEM\" | j\nIID=$(echo \"$ITEM\" | jq -r .id)\n\necho \"── GET públicos /items?available=true\"\ncurl -s \"$CAT/items?available=true\" | j\n\necho \"── GET privados  /items/me\"\nauth \"$CAT/items/me\" | j\n\necho \"── PATCH /items/$IID (añade Decoración, cambia precio)\"\nPATCH=$(jq --argjson cid ${CIDs[Decoración]} '{price_per_h:5.0,categories:[$cid]}' <<<\"{}\")\nauth -X PATCH \"$CAT/items/$IID\" \\\n     -H 'Content-Type: application/json' \\\n     -d \"$PATCH\" | j\n\necho \"── DELETE /items/$IID\"\nauth -X DELETE \"$CAT/items/$IID\" -w '\\n(status %{http_code})\\n'\n\necho \"── /items/me debería estar vacío\"\nauth \"$CAT/items/me\" | j\n\necho \"────────── 6) UPLOAD ───────────\"\nif [[ -f sample.jpg ]]; then\n  auth -X POST \"$CAT/upload/\" -F \"file=@sample.jpg\" | j\nelse\n  echo \"(sin sample.jpg; omitiendo)\"\nfi\n\necho -e \"\\n✅  tests completados\"\n",
    "catalog/alembic.ini": "[alembic]\nscript_location = migrations\nprepend_sys_path = .\nsqlalchemy.url = postgresql+psycopg2://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}\n\nversion_path_separator = os\n\n\n# ────────────── Logging ──────────────\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n\n[logger_root]\nlevel    = WARN\nhandlers = console\n\n\n[logger_sqlalchemy]\nlevel     = WARN\nqualname  = sqlalchemy.engine\nhandlers  = console\n\n\n[logger_alembic]\nlevel     = INFO\nqualname  = alembic\nhandlers  = console\n\n\n[handler_console]\nclass     = StreamHandler\nargs      = (sys.stderr,)\nformatter = generic\n\n\n[formatter_generic]\nformat   = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt  = %H:%M:%S\n",
    "catalog/migrations/script.py.mako": "\n\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n${imports if imports else \"\"}\n\nrevision = ${repr(up_revision)}\ndown_revision = ${repr(down_revision)}\nbranch_labels = ${repr(branch_labels)}\ndepends_on = ${repr(depends_on)}\n\n\ndef upgrade():\n    ${upgrades if upgrades else \"pass\"}\n\n\ndef downgrade():\n    ${downgrades if downgrades else \"pass\"}\n",
    "catalog/migrations/README": "",
    "catalog/migrations/env.py": "\n\"\"\"Alembic environment for Catalog service.\"\"\"\nfrom __future__ import annotations\n\nfrom logging.config import fileConfig\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\n\n# ─── configuración ────────────────────────────────────────────────────────\nconfig = context.config\nfileConfig(config.config_file_name)\n\n# Metadata\nfrom app.models.models import Base                                   # noqa: E402\ntarget_metadata = Base.metadata\ntarget_metadata.naming_convention = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\",\n}\n\n# URL de la BD → .env\nfrom app.core.config import settings                                # noqa: E402\nconfig.set_main_option(\"sqlalchemy.url\", settings.DATABASE_URL)\n\n\ndef run_migrations_offline() -> None:\n    context.configure(\n        url=config.get_main_option(\"sqlalchemy.url\"),\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n        compare_type=True,\n        compare_server_default=True,\n    )\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            target_metadata=target_metadata,\n            compare_type=True,\n            compare_server_default=True,\n        )\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n",
    "catalog/migrations/versions/20250714_0002_seed_default_categories.py": "\"\"\"Seed default categories\n\nRevision ID: 20250714_0002\nRevises: 20250713_0001\nCreate Date: 2025‑07‑14 12:00:00\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\nrevision = \"20250714_0002\"\ndown_revision = \"20250713_0001\"\nbranch_labels = None\ndepends_on = None\n\nDEFAULT_CATEGORIES = [\n    \"Herramientas\",\n    \"Electrónica\",\n    \"Deportes\",\n    \"Hogar\",\n    \"Jardín\",\n    \"Fotografía\",\n    \"Camping\",\n    \"Infantil\",\n]\n\n\ndef upgrade() -> None:\n    categories = sa.table(\"categories\", sa.column(\"name\", sa.String))\n    conn = op.get_bind()\n\n    existing = {row.name for row in conn.execute(sa.select(categories.c.name))}\n    to_insert = [{\"name\": n} for n in DEFAULT_CATEGORIES if n not in existing]\n\n    if to_insert:\n        op.bulk_insert(categories, to_insert)\n\n\ndef downgrade() -> None:\n    op.execute(\n        sa.text(\"DELETE FROM categories WHERE name = ANY(:names)\"),\n        {\"names\": DEFAULT_CATEGORIES},\n    )\n",
    "catalog/migrations/versions/20250713_0001_initial.py": "\"\"\"Initial schema\n\nRevision ID: 20250713_0001\nRevises:\nCreate Date: 2025‑07‑13 12:00:00\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n# ──────────────────────────────\nrevision = \"20250713_0001\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n# ──────────────────────────────\n\ndef upgrade() -> None:\n    op.create_table(\n        \"categories\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"name\", sa.String, nullable=False, unique=True, index=True),\n    )\n\n    op.create_table(\n        \"items\",\n        sa.Column(\"id\", sa.Integer, primary_key=True, index=True),\n        sa.Column(\"name\", sa.String, nullable=False, index=True),\n        sa.Column(\"description\", sa.String),\n        sa.Column(\"price_per_h\", sa.Float, nullable=False),\n        sa.Column(\"image_url\", sa.String),\n        sa.Column(\"owner_username\", sa.String, nullable=False, index=True),\n        sa.Column(\"available\", sa.Boolean, server_default=sa.text(\"true\"), nullable=False),\n    )\n\n    op.create_table(\n        \"item_images\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"item_id\", sa.Integer, sa.ForeignKey(\"items.id\", ondelete=\"CASCADE\"), nullable=False),\n        sa.Column(\"url\", sa.String, nullable=False),\n    )\n\n    op.create_table(\n        \"item_categories\",\n        sa.Column(\"item_id\", sa.Integer, sa.ForeignKey(\"items.id\", ondelete=\"CASCADE\"), primary_key=True),\n        sa.Column(\"category_id\", sa.Integer, sa.ForeignKey(\"categories.id\", ondelete=\"CASCADE\"), primary_key=True),\n    )\n\n\ndef downgrade() -> None:\n    op.drop_table(\"item_categories\")\n    op.drop_table(\"item_images\")\n    op.drop_table(\"items\")\n    op.drop_table(\"categories\")\n",
    "catalog/migrations/versions/20250715_0003_extend_items_with_details.py": "\"\"\"Amplía tabla items con campos avanzados\n\nRevision ID: 20250715_0003\nRevises    : 20250714_0002\nCreate Date: 2025‑07‑15 09:00:00\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import postgresql\n\nrevision = \"20250715_0003\"\ndown_revision = \"20250714_0002\"\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    with op.batch_alter_table(\"items\") as batch:\n        batch.add_column(sa.Column(\"compare_at_price\", sa.Float))\n        batch.add_column(sa.Column(\"sku\", sa.String(), unique=True))\n        batch.add_column(sa.Column(\"stock\", sa.Integer(), nullable=False, server_default=\"1\"))\n        batch.add_column(sa.Column(\"weight_kg\", sa.Float))\n        batch.add_column(sa.Column(\"shipping_type\", sa.String(length=20), nullable=False, server_default=\"free\"))\n        batch.add_column(sa.Column(\"condition\", sa.String(length=10), nullable=False, server_default=\"new\"))\n        batch.add_column(sa.Column(\"hashtags\", postgresql.ARRAY(sa.String)))\n\n\ndef downgrade() -> None:\n    with op.batch_alter_table(\"items\") as batch:\n        batch.drop_column(\"hashtags\")\n        batch.drop_column(\"condition\")\n        batch.drop_column(\"shipping_type\")\n        batch.drop_column(\"weight_kg\")\n        batch.drop_column(\"stock\")\n        batch.drop_column(\"sku\")\n        batch.drop_column(\"compare_at_price\")\n",
    "catalog/app/main.py": "# services/catalog/app/main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware  # MODIFIED: CORS\n\nfrom app.api import categories, items\nfrom app.models.database import Base, engine\nimport app.models.models                         #  noqa: F401\n\nfrom app.core.config import settings  # MODIFIED: Para CORS\n\napp = FastAPI(\n    title=\"rental-mvp – Catalog Service\",\n    docs_url=\"/docs\",\n    redoc_url=\"/redoc\",\n    openapi_url=\"/openapi.json\",\n)\n\n# MODIFIED: CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[settings.FRONTEND_URL],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.on_event(\"startup\")\ndef _init_db() -> None:\n    Base.metadata.create_all(bind=engine)\n\n@app.get(\"/health\")\ndef health():\n    return {\"ok\": True}\n\napp.include_router(categories.router, prefix=\"/api/categories\", tags=[\"categories\"])\napp.include_router(items.router,      prefix=\"/api/items\",      tags=[\"items\"])",
    "catalog/app/__init__.py": "",
    "catalog/app/deps.py": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import jwt, JWTError\nfrom sqlalchemy.orm import Session\n\nfrom app.models.database import SessionLocal\nfrom app.core.config import settings\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"dummy\")  # no lo usamos, solo valida header\n\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\ndef get_current_username(token: str = Depends(oauth2_scheme)) -> str:\n    \"\"\"Devuelve `sub` del JWT emitido por Auth.\"\"\"\n    cred_exc = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Credenciales no válidas\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str | None = payload.get(\"sub\")\n        if not username:\n            raise cred_exc\n        return username\n    except JWTError as e:  # MODIFIED: Granular\n        detail = \"Token expirado\" if \"exp\" in str(e) else \"Token inválido\"\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail)",
    "catalog/app/models/models.py": "from __future__ import annotations\n\nfrom typing import List\nfrom sqlalchemy import (\n    Boolean,\n    Column,\n    Float,\n    ForeignKey,\n    Integer,\n    String,\n    Table,\n)\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.dialects.postgresql import ARRAY\nfrom .database import Base\n\n# relación N:M items–categories\nitem_categories = Table(\n    \"item_categories\",\n    Base.metadata,\n    Column(\"item_id\", Integer, ForeignKey(\"items.id\", ondelete=\"CASCADE\"), primary_key=True),\n    Column(\"category_id\", Integer, ForeignKey(\"categories.id\", ondelete=\"CASCADE\"), primary_key=True),\n)\n\nclass ItemImage(Base):\n    __tablename__ = \"item_images\"\n\n    id = Column(Integer, primary_key=True)\n    item_id = Column(Integer, ForeignKey(\"items.id\", ondelete=\"CASCADE\"), nullable=False)\n    url = Column(String, nullable=False)\n\n    item = relationship(\"Item\", back_populates=\"images\")\n\n\nclass Category(Base):\n    __tablename__ = \"categories\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True, index=True, nullable=False)\n\n    items = relationship(\"Item\", secondary=item_categories, back_populates=\"categories\")\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True, nullable=False)\n    description = Column(String)\n    price_per_h = Column(Float, nullable=False)\n\n    compare_at_price = Column(Float)                            # 🆕\n    sku = Column(String, unique=True)                           # 🆕\n    stock = Column(Integer, default=1)                          # 🆕\n    weight_kg = Column(Float)                                   # 🆕\n    shipping_type = Column(String(20), default=\"free\")          # 🆕 \"free\" | \"local_pickup\" | \"paid\"\n    condition = Column(String(10), default=\"new\")               # 🆕 \"new\"  | \"used\"\n    hashtags = Column(ARRAY(String))                            # 🆕  TEXT[]\n\n    image_url = Column(String)           # destacado (legacy)\n    owner_username = Column(String, index=True, nullable=False)\n    available = Column(Boolean, default=True)\n\n    # relaciones\n    categories = relationship(\"Category\", secondary=item_categories, back_populates=\"items\")\n    images = relationship(\n        \"ItemImage\",\n        back_populates=\"item\",\n        cascade=\"all, delete-orphan\",\n        order_by=\"ItemImage.id\",\n    )\n\n    # helper\n    @property\n    def image_urls(self) -> List[str]:\n        return [img.url for img in self.images]",
    "catalog/app/models/__init__.py": "# importa modelos para que Alembic los detecte\nfrom .models import Category, Item, ItemImage  # noqa: F401",
    "catalog/app/models/database.py": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.core.config import settings\n\nconnect_args = {\"check_same_thread\": False} if settings.DATABASE_URL.startswith(\"sqlite\") else {}\nengine = create_engine(settings.DATABASE_URL, connect_args=connect_args, echo=True)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()",
    "catalog/app/schemas/category.py": "from pydantic import BaseModel, Field\n\n\nclass CategoryBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=50)\n\n\nclass CategoryCreate(CategoryBase):\n    pass\n\n\nclass CategoryOut(CategoryBase):\n    id: int\n\n    class Config:\n        from_attributes = True",
    "catalog/app/schemas/__init__.py": "from .category import CategoryCreate, CategoryOut\nfrom .item import ItemCreate, ItemUpdate, ItemOut\n\n__all__ = [\n    \"CategoryCreate\",\n    \"CategoryOut\",\n    \"ItemCreate\",\n    \"ItemUpdate\",\n    \"ItemOut\",\n]",
    "catalog/app/schemas/item.py": "from __future__ import annotations\nfrom typing import List, Optional\nfrom pydantic import BaseModel, Field, PositiveFloat, AfterValidator, StringConstraints\nfrom typing_extensions import Annotated\nfrom pydantic import field_validator  \nfrom .category import CategoryOut\n\n# ─── validadores auxiliares ────────────────────────────────────────────\ndef _check_url(v: str) -> str:\n    if v.startswith((\"http://\", \"https://\", \"/\")):\n        return v\n    raise ValueError(\"url debe ser http(s)://… o empezar por /uploads/…\")\n\nUrlStr = Annotated[str, AfterValidator(_check_url)]\nHashtag = Annotated[str, StringConstraints(pattern=\"^#[A-Za-z0-9_]{1,30}$\")]\n\n# ─── BASE ──────────────────────────────────────────────────────────────\nclass ItemBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=80)\n    description: Optional[str] = None\n    price_per_h: PositiveFloat\n    compare_at_price: Optional[PositiveFloat] = None\n    sku: Optional[str] = Field(None, max_length=40)\n    stock: int = Field(1, ge=0)\n    weight_kg: Optional[PositiveFloat] = None\n    shipping_type: str = Field(\"free\", pattern=\"^(free|local_pickup|paid)$\")\n    condition: str = Field(\"new\", pattern=\"^(new|used)$\")\n\n    # ── ⚠️ el problema estaba aquí ─────────────────────────\n    hashtags: List[Hashtag] = Field(default_factory=list, max_items=5)\n\n    # ⬇️ normaliza None → []\n    @field_validator(\"hashtags\", mode=\"before\")\n    @classmethod\n    def _none_to_list(cls, v):\n        # Pydantic llama al validador antes de validar tipos ⇒\n        # si viene None devolvemos lista vacía\n        return v or []\n\n\n# ─── CREATE ────────────────────────────────────────────────────────────\nclass ItemCreate(ItemBase):\n    image_urls: List[UrlStr] = Field(..., min_length=1, max_length=10)\n    categories: Optional[List[int]] = Field(\n        default=None, description=\"IDs de categorías asociadas\"\n    )\n\n# ─── UPDATE ────────────────────────────────────────────────────────────\nclass ItemUpdate(BaseModel):\n    # todos opcionales\n    name: Optional[str] = Field(None, min_length=1, max_length=80)\n    description: Optional[str] = None\n    price_per_h: Optional[PositiveFloat] = None\n    compare_at_price: Optional[PositiveFloat] = None\n    sku: Optional[str] = Field(None, max_length=40)\n    stock: Optional[int] = Field(None, ge=0)\n    weight_kg: Optional[PositiveFloat] = None\n    shipping_type: Optional[str] = Field(None, pattern=\"^(free|local_pickup|paid)$\")\n    condition: Optional[str] = Field(None, pattern=\"^(new|used)$\")\n    hashtags: Optional[List[Hashtag]] = Field(default=None, max_items=5)\n    image_urls: Optional[List[UrlStr]] = Field(None, min_items=1, max_items=10)\n    categories: Optional[List[int]] = None\n\n    model_config = {\"extra\": \"forbid\"}\n\n# ─── OUT ───────────────────────────────────────────────────────────────\nclass ItemOut(ItemBase):\n    id: int\n    available: bool\n    owner_username: str\n    categories: List[CategoryOut]\n    image_urls: List[UrlStr]\n    image_url: Optional[UrlStr] = None  # compat\n\n    model_config = {\"from_attributes\": True}\n",
    "catalog/app/crud/category.py": "from typing import List, Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom app.models.models import Category\nfrom app.schemas.category import CategoryCreate\n\n\ndef get_category(db: Session, cat_id: int) -> Optional[Category]:\n    return db.query(Category).filter(Category.id == cat_id).first()\n\n\ndef get_categories(db: Session) -> List[Category]:\n    return db.query(Category).order_by(Category.name).all()\n\n\ndef create_category(db: Session, cat_in: CategoryCreate) -> Category:\n    db_cat = Category(**cat_in.model_dump())\n    db.add(db_cat)\n    db.commit()\n    db.refresh(db_cat)\n    return db_cat",
    "catalog/app/crud/__init__.py": "from .category import get_category, get_categories, create_category           # noqa: F401\nfrom .item import (                                                           # noqa: F401\n    get_item,\n    get_items,\n    get_items_by_owner,\n    create_item,\n    update_item,\n    delete_item,\n)\n\n__all__ = [\n    \"get_category\",\n    \"get_categories\",\n    \"create_category\",\n    \"get_item\",\n    \"get_items\",\n    \"get_items_by_owner\",\n    \"create_item\",\n    \"update_item\",\n    \"delete_item\",\n]",
    "catalog/app/crud/item.py": "from __future__ import annotations\n\nfrom typing import List, Optional, Tuple\n\nfrom sqlalchemy import asc, desc, or_\nfrom sqlalchemy.orm import Session, joinedload\n\nfrom app.models.models import Category, Item, ItemImage\nfrom app.schemas.item import ItemCreate, ItemUpdate\n\n# ───────── helpers internos ───────────────────────────────────────────────\ndef _get_categories_or_400(db: Session, ids: list[int]) -> list[Category]:\n    cats = db.query(Category).filter(Category.id.in_(ids)).all()\n    if len(cats) != len(ids):\n        missing = set(ids) - {c.id for c in cats}\n        raise ValueError(f\"Categorías inexistentes: {', '.join(map(str, missing))}\")\n    return cats\n\n\ndef _apply_order(q, order_by: str | None, order_dir: str | None):\n    mapping = {\"price\": Item.price_per_h, \"name\": Item.name, \"id\": Item.id}\n    if not order_by:\n        return q.order_by(Item.id)\n    col = mapping.get(order_by, Item.id)\n    return q.order_by(asc(col) if order_dir == \"asc\" else desc(col))\n\n\n# ───────── lectura ────────────────────────────────────────────────────────\ndef get_item(db: Session, item_id: int) -> Optional[Item]:\n    return (\n        db.query(Item)\n        .options(joinedload(Item.categories), joinedload(Item.images))\n        .filter(Item.id == item_id)\n        .first()\n    )\n\n\ndef _build_query(\n    db: Session,\n    *,\n    name: Optional[str],\n    min_price: Optional[float],\n    max_price: Optional[float],\n    available: Optional[bool],\n    categories: Optional[List[int]],\n    order_by: Optional[str],\n    order_dir: Optional[str],\n):\n    q = db.query(Item).options(joinedload(Item.categories), joinedload(Item.images))\n\n    if name:\n        pattern = f\"%{name}%\"\n        q = q.filter(or_(Item.name.ilike(pattern), Item.description.ilike(pattern)))\n    if min_price is not None:\n        q = q.filter(Item.price_per_h >= min_price)\n    if max_price is not None:\n        q = q.filter(Item.price_per_h <= max_price)\n    if available is not None:\n        q = q.filter(Item.available == available)\n    if categories:\n        q = q.filter(Item.categories.any(Category.id.in_(categories)))\n\n    return _apply_order(q, order_by, order_dir)\n\n\ndef get_items(\n    db: Session,\n    skip: int,\n    limit: int,\n    *,\n    name: Optional[str],\n    min_price: Optional[float],\n    max_price: Optional[float],\n    available: Optional[bool],\n    categories: Optional[List[int]],\n    order_by: Optional[str],\n    order_dir: Optional[str],\n) -> Tuple[List[Item], int]:\n    q = _build_query(\n        db,\n        name=name,\n        min_price=min_price,\n        max_price=max_price,\n        available=available,\n        categories=categories,\n        order_by=order_by,\n        order_dir=order_dir,\n    )\n    total = q.count()\n    items = q.offset(skip).limit(limit).all()\n    return items, total\n\n\ndef get_items_by_owner(db: Session, owner: str) -> List[Item]:\n    return (\n        db.query(Item)\n        .options(joinedload(Item.categories), joinedload(Item.images))\n        .filter(Item.owner_username == owner)\n        .all()\n    )\n\n\n# ───────── escritura ──────────────────────────────────────────────────────\ndef create_item(db: Session, item_in: ItemCreate, owner_username: str) -> Item:\n    main = str(item_in.image_urls[0])\n\n    db_item = Item(\n        name=item_in.name,\n        description=item_in.description,\n        price_per_h=item_in.price_per_h,\n        compare_at_price=item_in.compare_at_price,\n        sku=item_in.sku,\n        stock=item_in.stock,\n        weight_kg=item_in.weight_kg,\n        shipping_type=item_in.shipping_type,\n        condition=item_in.condition,\n        hashtags=item_in.hashtags,\n        image_url=main,\n        owner_username=owner_username,\n    )\n\n    if item_in.categories:\n        db_item.categories = _get_categories_or_400(db, item_in.categories)\n\n    db_item.images = [ItemImage(url=str(u)) for u in item_in.image_urls]\n\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item\n\n\ndef update_item(db: Session, db_item: Item, item_in: ItemUpdate) -> Item:\n    data = item_in.model_dump(\n        exclude_unset=True, exclude={\"categories\", \"image_urls\"}\n    )\n    for k, v in data.items():\n        setattr(db_item, k, v)\n\n    if item_in.categories is not None:\n        db_item.categories = _get_categories_or_400(db, item_in.categories)\n\n    if item_in.image_urls is not None:\n        db_item.image_url = str(item_in.image_urls[0])\n        db_item.images = [ItemImage(url=str(u)) for u in item_in.image_urls]\n\n    db.commit()\n    db.refresh(db_item)\n    return db_item\n\n\ndef delete_item(db: Session, db_item: Item) -> None:\n    db.delete(db_item)\n    db.commit()",
    "catalog/app/core/__init__.py": "",
    "catalog/app/core/config.py": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    FRONTEND_URL: str | None = None  # MODIFIED: Optional\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60\n\n    model_config = SettingsConfigDict(env_file=\".env\", extra=\"ignore\")\n\n\nsettings = Settings()",
    "catalog/app/api/items.py": "from typing import List, Optional\nfrom urllib.parse import urlencode\n\nfrom fastapi import (\n    APIRouter,\n    Depends,\n    HTTPException,\n    Query,\n    Request,\n    Response,\n    status,\n)\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, schemas\nfrom app.deps import get_db, get_current_username\n\nrouter = APIRouter()\n\n# ───────── helpers paginación RFC-5988 ────────────────────────────────────\ndef _pagination_links(request: Request, skip: int, limit: int, total: int, **flt):\n    links: list[str] = []\n    base = request.url.remove_query_params(\"skip\").remove_query_params(\"limit\")\n\n    def _url(new_skip: int):\n        params = {k: v for k, v in flt.items() if v is not None}\n        params.update({\"skip\": new_skip, \"limit\": limit})\n        return f\"<{base}?{urlencode(params, doseq=True)}>\"\n\n    if skip + limit < total:\n        links.append(f'{_url(skip + limit)}; rel=\"next\"')\n    if skip > 0:\n        links.append(f'{_url(max(skip - limit,0))}; rel=\"prev\"')\n    return \", \".join(links)\n\n\n# ───────────── crear ─────────────────────────────────────────────────────\n@router.post(\"/\", response_model=schemas.ItemOut, status_code=status.HTTP_201_CREATED)\ndef create_item(\n    item_in: schemas.ItemCreate,\n    db: Session = Depends(get_db),\n    username: str = Depends(get_current_username),\n):\n    return crud.create_item(db, item_in, owner_username=username)\n\n\n# ───────────── listar público ────────────────────────────────────────────\n@router.get(\"/\", response_model=List[schemas.ItemOut])\ndef list_items(\n    request: Request,\n    response: Response,\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    name: Optional[str] = None,\n    min_price: Optional[float] = Query(None, ge=0),\n    max_price: Optional[float] = Query(None, ge=0),\n    available: Optional[bool] = None,\n    categories: Optional[List[int]] = Query(None),\n    order_by: Optional[str] = Query(None, pattern=\"^(price|name|id)$\"),\n    order_dir: Optional[str] = Query(None, pattern=\"^(asc|desc)$\"),\n    db: Session = Depends(get_db),\n):\n    items, total = crud.get_items(\n        db,\n        skip,\n        limit,\n        name=name,\n        min_price=min_price,\n        max_price=max_price,\n        available=available,\n        categories=categories,\n        order_by=order_by,\n        order_dir=order_dir,\n    )\n    response.headers[\"X-Total-Count\"] = str(total)\n    if total:\n        link = _pagination_links(\n            request,\n            skip,\n            limit,\n            total,\n            name=name,\n            min_price=min_price,\n            max_price=max_price,\n            available=available,\n            categories=categories,\n            order_by=order_by,\n            order_dir=order_dir,\n        )\n        if link:\n            response.headers[\"Link\"] = link\n    return items\n\n\n# ───────────── mis ítems ────────────────────────────────────────────────\n@router.get(\"/me\", response_model=List[schemas.ItemOut])\ndef my_items(\n    db: Session = Depends(get_db),\n    username: str = Depends(get_current_username),\n):\n    return crud.get_items_by_owner(db, username)\n\n\n# ───────────── actualizar ───────────────────────────────────────────────\n@router.patch(\"/{item_id}\", response_model=schemas.ItemOut)\ndef patch_item(\n    item_id: int,\n    item_in: schemas.ItemUpdate,\n    db: Session = Depends(get_db),\n    username: str = Depends(get_current_username),\n):\n    db_item = crud.get_item(db, item_id)\n    if not db_item or db_item.owner_username != username:\n        raise HTTPException(404, \"Item no encontrado\")\n    return crud.update_item(db, db_item, item_in)\n\n\n@router.put(\"/{item_id}\", response_model=schemas.ItemOut)\ndef put_item(\n    item_id: int,\n    item_in: schemas.ItemCreate,\n    db: Session = Depends(get_db),\n    username: str = Depends(get_current_username),\n):\n    db_item = crud.get_item(db, item_id)\n    if not db_item or db_item.owner_username != username:\n        raise HTTPException(404, \"Item no encontrado\")\n    return crud.update_item(db, db_item, schemas.ItemUpdate(**item_in.model_dump()))\n\n# ───────────── obtener 1 ítem ────────────────────────────────────────────\n@router.get(\"/{item_id}\", response_model=schemas.ItemOut)\ndef get_item(\n    item_id: int,\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Devuelve un único ítem por *ID*.\n\n    404 si no existe.\n    \"\"\"\n    db_item = crud.get_item(db, item_id)\n    if not db_item:\n        raise HTTPException(404, \"Item no encontrado\")\n    return db_item\n\n\n\n# ───────────── eliminar ────────────────────────────────────────────────\n@router.delete(\"/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_item(\n    item_id: int,\n    db: Session = Depends(get_db),\n    username: str = Depends(get_current_username),\n):\n    db_item = crud.get_item(db, item_id)\n    if not db_item or db_item.owner_username != username:\n        raise HTTPException(404, \"Item no encontrado\")\n    crud.delete_item(db, db_item)",
    "catalog/app/api/categories.py": "from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, schemas\nfrom app.deps import get_db, get_current_username\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=List[schemas.CategoryOut])\ndef list_categories(db: Session = Depends(get_db)):\n    return crud.get_categories(db)\n\n\n@router.post(\n    \"/\", response_model=schemas.CategoryOut, status_code=status.HTTP_201_CREATED\n)\ndef create_category(\n    cat_in: schemas.CategoryCreate,\n    db: Session = Depends(get_db),\n    _user=Depends(get_current_username),        # solo autenticados\n):\n    return crud.create_category(db, cat_in)\n\n\n@router.get(\"/{cat_id}\", response_model=schemas.CategoryOut)\ndef get_category(cat_id: int, db: Session = Depends(get_db)):\n    cat = crud.get_category(db, cat_id)\n    if not cat:\n        raise HTTPException(404, \"Categoría no encontrada\")\n    return cat",
    "catalog/app/api/__init__.py": "",
    "catalog/app/api/upload.py": "# services/catalog/app/api/upload.py\n\"\"\"\nEndpoint para subir imágenes desde el catálogo.\nTambién devuelve la **ruta relativa** /uploads/…  para evitar problemas de host.\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport shutil\nimport uuid\nfrom pathlib import Path\n\nfrom fastapi import (\n    APIRouter,\n    Depends,\n    HTTPException,\n    Request,\n    UploadFile,\n    status,\n)\n\nfrom app.deps import get_current_username\n\nUPLOAD_DIR = Path(__file__).resolve().parent.parent / \"uploads\"\nUPLOAD_DIR.mkdir(exist_ok=True)\n\nrouter = APIRouter()\n\n\n@router.post(\"/\", status_code=status.HTTP_201_CREATED)\nasync def upload_image(\n    file: UploadFile,\n    request: Request,\n    _user=Depends(get_current_username),\n):\n    if not file.content_type.startswith(\"image/\"):\n        raise HTTPException(400, \"Solo imágenes\")\n\n    ext = Path(file.filename).suffix\n    name = f\"{uuid.uuid4()}{ext}\"\n    path = UPLOAD_DIR / name\n\n    with path.open(\"wb\") as buf:\n        shutil.copyfileobj(file.file, buf)\n\n    # ← ruta relativa\n    return {\"url\": f\"/uploads/{name}\"}\n"
}
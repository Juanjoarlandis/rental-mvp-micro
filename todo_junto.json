{
    "auth/requirements.txt": "fastapi==0.116.0\nuvicorn==0.35.0\n\npydantic==2.11.7\npydantic-core==2.33.2\npydantic-settings==2.10.1\n\nSQLAlchemy==2.0.41\npsycopg2-binary==2.9.6\n\npython-jose[cryptography]==3.5.0\npasslib==1.7.4\nbcrypt==3.2.2\npython-multipart==0.0.6\npython-dotenv==1.1.1\n\n# rate‑limit\nslowapi==0.1.8\n\n# extras (rendimiento opc.)\nuvloop==0.21.0\nhttptools==0.6.4\nemail-validator==2.1.1\nalembic==1.16.4\npytest==8.2.0\npytest-cov==5.0.0",
    "auth/.env": "# services/auth/.env\nDATABASE_URL=postgresql+psycopg2://auth_user:auth_pass@auth-db:5432/auth\nSECRET_KEY=SuperClaveUltraSecreta\nFRONTEND_URL=http://frontend",
    "auth/Dockerfile": "### ───────────────────────── build stage ─────────────────────────\nFROM python:3.12-slim AS base\n\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1\n\n# Herramientas y headers para compilar wheels (psycopg2, bcrypt, etc.)\nRUN apt-get update \\\n    && apt-get install -y --no-install-recommends \\\n    build-essential \\\n    libffi-dev \\\n    libpq-dev \\          \n    && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n\n### ───────────────────────── runtime stage ───────────────────────\n#  Contenedor final ► sin root  +  sólo dependencias runtime\nFROM python:3.12-slim\n\n# 1️⃣  libpq5 *runtime* – lo mínimo para que psycopg2 funcione\nRUN apt-get update \\\n    && apt-get install -y --no-install-recommends libpq5 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 2️⃣  Copiamos todo lo instalado por pip en el stage base\nCOPY --from=base /usr/local /usr/local\n\nWORKDIR /app\nENV PYTHONPATH=/app\n\n# 3️⃣  Creamos un usuario no-root y lo usamos\nRUN adduser --disabled-password --gecos '' appuser\nUSER appuser\n\n# 4️⃣  Código y configuración\nCOPY --chown=appuser:appuser app/          ./app\nCOPY --chown=appuser:appuser migrations/   ./migrations\nCOPY --chown=appuser:appuser alembic.ini   .\nCOPY --chown=appuser:appuser .env          .\n\nEXPOSE 8000\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n",
    "auth/alembic.ini": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = migrations\n\n# template used to generate migration files\n# file_template = %%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version location specification; This defaults\n# to migrations/versions.  When using multiple version\n# directories, initial revisions must be specified with --version-path.\n# The path separator used here should be the separator specified by \"version_path_separator\" below.\n# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses os.pathsep.\n# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\nversion_path_separator = os  # Use os.pathsep. Default configuration used for new projects.\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\n# alembic.ini\nsqlalchemy.url = postgresql+psycopg2://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}\n\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = console_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S\n",
    "auth/migrations/script.py.mako": "\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n${imports if imports else \"\"}\n\n# revision identifiers, used by Alembic.\nrevision = ${repr(up_revision)}\ndown_revision = ${repr(down_revision)}\nbranch_labels = ${repr(branch_labels)}\ndepends_on = ${repr(depends_on)}\n\n\ndef upgrade():\n    ${upgrades if upgrades else \"pass\"}\n\n\ndef downgrade():\n    ${downgrades if downgrades else \"pass\"}\n",
    "auth/migrations/README": "Generic single-database configuration.",
    "auth/migrations/env.py": "# migrations/env.py\n\"\"\"Alembic migration environment for the Auth service.\"\"\"\n\nfrom __future__ import annotations\n\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\n\n# ────────────────────────────────────────────────────────\n# 1. Configuración y logging\n# ────────────────────────────────────────────────────────\nconfig = context.config\nfileConfig(config.config_file_name)\n\n# ────────────────────────────────────────────────────────\n# 2. Metadata de modelos  → autogenerate\n# ────────────────────────────────────────────────────────\nfrom app.models.models import Base  # importa las tablas\ntarget_metadata = Base.metadata\n\n# (opcional, pero aconsejado: convenciones de nombres)\ntarget_metadata.naming_convention = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\",\n}\n\n# ────────────────────────────────────────────────────────\n# 3. URL de conexión: utiliza la misma que tu servicio\n# ────────────────────────────────────────────────────────\nfrom app.core.config import settings  # noqa: E402\n\nconfig.set_main_option(\"sqlalchemy.url\", settings.DATABASE_URL)\n\n# ────────────────────────────────────────────────────────\n# 4. Hooks offline / online\n# ────────────────────────────────────────────────────────\ndef run_migrations_offline() -> None:\n    \"\"\"Genera SQL sin tocar la BD (alembic upgrade --sql).\"\"\"\n    context.configure(\n        url=config.get_main_option(\"sqlalchemy.url\"),\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n        compare_type=True,\n        compare_server_default=True,\n    )\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Aplica las migraciones sobre la BD.\"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            target_metadata=target_metadata,\n            compare_type=True,\n            compare_server_default=True,\n        )\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n",
    "auth/migrations/versions/20250712_init.py": "\"\"\"tabla users inicial\n\nRevision ID: 20250712_init\nRevises:\nCreate Date: 2025-07-12 00:00:00\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n# revision identifiers, used by Alembic.\nrevision = \"20250712_init\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"users\",\n        sa.Column(\"id\", sa.Integer(), primary_key=True, nullable=False),\n        sa.Column(\"username\", sa.String(), nullable=False),\n        sa.Column(\"email\", sa.String(), nullable=False),\n        sa.Column(\"hashed_pw\", sa.String(), nullable=False),\n        sa.UniqueConstraint(\"username\"),\n        sa.UniqueConstraint(\"email\"),\n    )\n    op.create_index(\"ix_users_username\", \"users\", [\"username\"])\n    op.create_index(\"ix_users_email\", \"users\", [\"email\"])\n\n\ndef downgrade() -> None:\n    op.drop_index(\"ix_users_email\", table_name=\"users\")\n    op.drop_index(\"ix_users_username\", table_name=\"users\")\n    op.drop_table(\"users\")\n",
    "auth/app/main.py": "# services/auth/app/main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware  # MODIFIED: Importado para CORS\nfrom slowapi import _rate_limit_exceeded_handler\nfrom slowapi.errors import RateLimitExceeded\n\nfrom app.api import auth, health, password          # ← nuevos routers\nfrom app.core.ratelimit import limiter\nfrom app.models.database import Base, engine\nimport app.models.models        # noqa: F401  (importa tablas)\n\nfrom app.core.config import settings  # MODIFIED: Para orígenes CORS\n\napp = FastAPI(\n    title=\"rental‑mvp – Auth Service\",\n    version=\"1.0.0\",\n    docs_url=\"/docs\",\n    redoc_url=\"/redoc\",\n    openapi_url=\"/openapi/v1.json\",   # ← OpenAPI versionada\n)\n\n# MODIFIED: Añadir CORS middleware (best practice: orígenes específicos)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[settings.FRONTEND_URL],  # De .env o config\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# ─────────── BD auto‑create (solo dev) ───────────\n@app.on_event(\"startup\")\ndef _init_db() -> None:\n    Base.metadata.create_all(bind=engine)\n\n# ─────────── Rate‑limit global handler ───────────\napp.state.limiter = limiter\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n# ─────────── Rutas ───────────\napp.include_router(auth.router,     prefix=\"/api/auth\")\napp.include_router(password.router, prefix=\"/api/auth\")\napp.include_router(health.router)   # /health a raíz",
    "auth/app/__init__.py": "",
    "auth/app/deps.py": "# services/auth/app/deps.py\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import jwt, JWTError\nfrom sqlalchemy.orm import Session\n\nfrom app.models.database import SessionLocal\nfrom app.core.config import settings\nfrom app.crud import user as crud\nfrom app.schemas.user import UserOut\n\n# ──────────── DB session ────────────\ndef get_db() -> Session:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\n# ──────────── Auth helper ───────────\noauth2_scheme = OAuth2PasswordBearer(\n    tokenUrl=\"/api/auth/token\"   # el prefijo '/api/auth' se añade en main.py\n)\n\n\ndef get_current_user(\n    token: str = Depends(oauth2_scheme),\n    db: Session = Depends(get_db),\n) -> UserOut:\n    \"\"\"\n    Valida el JWT y devuelve el usuario asociado.\n    Lanza 401 si es inválido o no existe.\n    \"\"\"\n    # MODIFIED: Mejora - Añadido manejo de expiración y scopes si aplica\n    cred_exc = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Credenciales no válidas\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str | None = payload.get(\"sub\")\n        if not username:\n            raise cred_exc\n    except JWTError as e:  # MODIFIED: Más granular (expirado, inválido)\n        detail = \"Token expirado\" if \"exp\" in str(e) else \"Token inválido\"\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail)\n\n    user = crud.get_user_by_username(db, username)\n    if not user:\n        raise cred_exc\n    return user",
    "auth/app/models/models.py": "from sqlalchemy import Column, Integer, String\nfrom app.models.database import Base   # usa SIEMPRE la misma Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id        = Column(Integer, primary_key=True)\n    username  = Column(String, unique=True, index=True, nullable=False)\n    email     = Column(String, unique=True, index=True, nullable=False)\n    hashed_pw = Column(String, nullable=False)\n",
    "auth/app/models/__init__.py": "",
    "auth/app/models/database.py": "# services/auth/app/models/database.py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom app.core.config import settings\n\nconnect_args = {\"check_same_thread\": False} if settings.DATABASE_URL.startswith(\"sqlite\") else {}\n\nengine = create_engine(\n    settings.DATABASE_URL,\n    connect_args=connect_args,\n    echo=True,\n)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n",
    "auth/app/schemas/token.py": "# app/schemas/token.py\nfrom pydantic import BaseModel\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n",
    "auth/app/schemas/__init__.py": "from .user import UserCreate, UserOut  # noqa: F401\n\n__all__ = [\"UserCreate\", \"UserOut\"]\n",
    "auth/app/schemas/user.py": "from pydantic import BaseModel, EmailStr, ConfigDict\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n\nclass UserOut(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n    model_config = ConfigDict(from_attributes=True)  # ← en vez del viejo Config\n",
    "auth/app/crud/__init__.py": "# services/auth/app/crud/__init__.py\nfrom .user import (\n    get_user_by_username,\n    get_user_by_email,\n    create_user,\n    verify_password,\n)\n\n__all__ = [\n    \"get_user_by_username\",\n    \"get_user_by_email\",\n    \"create_user\",\n    \"verify_password\",\n]\n",
    "auth/app/crud/user.py": "# app/crud/user.py\nfrom __future__ import annotations\n\nimport bcrypt\nfrom passlib.context import CryptContext\nfrom sqlalchemy.orm import Session\n\nfrom app.models.models import User\nfrom app.schemas.user import UserCreate\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# ───────────────────────── helpers privados ──────────────────────────────\n\n\ndef _hash_password(pwd: str) -> str:\n    \"\"\"Devuelve el hash seguro de *pwd* usando passlib/bcrypt.\"\"\"\n    return pwd_context.hash(pwd)\n\n\n# ────────────────────────────── Lectura ───────────────────────────────────\n\n\ndef get_user_by_username(db: Session, username: str) -> User | None:\n    \"\"\"Busca un usuario por *username* (o None si no existe).\"\"\"\n    return db.query(User).filter(User.username == username).first()\n\n\ndef get_user_by_email(db: Session, email: str) -> User | None:\n    \"\"\"Busca un usuario por email (o None si no existe).\"\"\"\n    return db.query(User).filter(User.email == email).first()\n\n\n# ───────────────────────────── Escritura ──────────────────────────────────\n\n\ndef create_user(db: Session, user_in: UserCreate) -> User:\n    \"\"\"\n    Crea un nuevo usuario con contraseña hasheada y lo devuelve.\n    Lanza IntegrityError si el username/email ya existen.\n    \"\"\"\n    db_user = User(\n        username=user_in.username,\n        email=user_in.email,\n        hashed_pw=_hash_password(user_in.password),\n    )\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n\n\n# ──────────────────────── Utilidades varias ──────────────────────────────\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"\n    Comprueba que *plain_password* coincide con el hash almacenado.\n    Se usa bcrypt directamente para evitar dependencias implícitas.\n    \"\"\"\n    try:\n        return bcrypt.checkpw(plain_password.encode(), hashed_password.encode())\n    except Exception:  # noqa: BLE001\n        # bcrypt lanza ValueError si el hash no es válido\n        return False\n",
    "auth/app/core/ratelimit.py": "from slowapi import Limiter\nfrom slowapi.util import get_remote_address\n\n# instancia única que compartirán todos los routers\n# MODIFIED: Auditado - límites más estrictos para prevenir abuso\nlimiter = Limiter(key_func=get_remote_address, default_limits=[\"100/minute\"])  # Límite global por IP",
    "auth/app/core/__init__.py": "",
    "auth/app/core/config.py": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass Settings(BaseSettings):\n    FRONTEND_URL: str | None = None  # MODIFIED: Optional\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60\n\n    model_config = SettingsConfigDict(env_file=\".env\", extra=\"ignore\")\n\nsettings = Settings()        # instancia global\n",
    "auth/app/core/security.py": "# services/auth/app/core/security.py\nfrom datetime import datetime, timedelta\nfrom jose import jwt, JWTError\n\nfrom app.core.config import settings\n\n# ───────── JWT genérico ──────────────────────────────────────────\ndef _encode(payload: dict, minutes: int) -> str:\n    exp = datetime.utcnow() + timedelta(minutes=minutes)\n    payload.update({\"exp\": exp})\n    return jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n\n\n# ───────── Access token (igual) ─────────────────────────────────\ndef create_access_token(subject: str) -> str:\n    return _encode({\"sub\": subject}, settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n\n\n# ───────── Reset‑password token ────────────────────────────────\nRESET_TOKEN_MINUTES = 15     # caduca rápido\n\ndef create_reset_token(username: str) -> str:\n    return _encode({\"sub\": username, \"scope\": \"pwd_reset\"}, RESET_TOKEN_MINUTES)\n\n\ndef verify_reset_token(token: str) -> str | None:\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        if payload.get(\"scope\") != \"pwd_reset\":\n            return None\n        return payload.get(\"sub\")\n    except JWTError:\n        return None\n",
    "auth/app/api/password.py": "# services/auth/app/api/password.py\nfrom fastapi import (\n    APIRouter,\n    Depends,\n    HTTPException,\n    Request,      # 👈 necesario para slowapi\n    status,\n)\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import Session\n\nfrom app.deps import get_db\nfrom app.core.security import create_reset_token, verify_reset_token\nfrom app.crud import user as crud\nfrom app.core.ratelimit import limiter\n\nrouter = APIRouter(tags=[\"password\"])\n\n# ───────── forgotten ────────────────────────────────────────────\nclass ForgotIn(BaseModel):\n    username: str = Field(..., min_length=3)\n\n\nclass ForgotOut(BaseModel):\n    reset_token: str\n\n\n@router.post(\"/password/forgot\", response_model=ForgotOut)\n@limiter.limit(\"3/minute\")\ndef forgot(\n    request: Request,           # 👈 obligatorio\n    data: ForgotIn,\n    db: Session = Depends(get_db),\n):\n    user = crud.get_user_by_username(db, data.username)\n    if not user:\n        raise HTTPException(status.HTTP_404_NOT_FOUND, \"Usuario no encontrado\")\n    token = create_reset_token(user.username)\n    # MVP → devolvemos el token; en prod se enviaría por email\n    return {\"reset_token\": token}\n\n\n# ───────── reset ────────────────────────────────────────────────\nclass ResetIn(BaseModel):\n    token: str\n    new_password: str = Field(..., min_length=8)\n\n\n@router.post(\"/password/reset\", status_code=status.HTTP_204_NO_CONTENT)\n@limiter.limit(\"3/minute\")\ndef reset(\n    request: Request,           # 👈 obligatorio\n    data: ResetIn,\n    db: Session = Depends(get_db),\n):\n    username = verify_reset_token(data.token)\n    if not username:\n        raise HTTPException(status.HTTP_400_BAD_REQUEST, \"Token inválido o expirado\")\n\n    user = crud.get_user_by_username(db, username)\n    if not user:\n        raise HTTPException(status.HTTP_404_NOT_FOUND, \"Usuario no encontrado\")\n\n    # actualiza hash\n    user.hashed_pw = crud.pwd_context.hash(data.new_password)\n    db.commit()\n",
    "auth/app/api/health.py": "# services/auth/app/api/health.py\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy import text            # 👈🏻 NEW\n\nfrom app.deps import get_db\n\nrouter = APIRouter(tags=[\"health\"])\n\n@router.get(\"/health\", summary=\"Lightweight liveness & DB check\")\ndef health(db: Session = Depends(get_db)):\n    try:\n        # SQLAlchemy 2.0 exige usar text() para SQL literal\n        db.execute(text(\"SELECT 1\"))   # 👈🏻 FIX\n        db_status = \"ok\"\n    except SQLAlchemyError:\n        db_status = \"error\"\n    return {\"ok\": True, \"db\": db_status}\n",
    "auth/app/api/auth.py": "# services/auth/app/api/auth.py   ← versión completa ⚡️\nfrom fastapi import (\n    APIRouter,\n    Depends,\n    HTTPException,\n    Request,          # 👈 necesario para slowapi\n    status,\n)\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session\n\nfrom app.deps import get_db, get_current_user\nfrom app.crud import user as crud\nfrom app.schemas.user import UserCreate, UserOut\nfrom app.schemas.token import Token\nfrom app.core.security import create_access_token\nfrom app.core.ratelimit import limiter                 # 🆕\n\nrouter = APIRouter(tags=[\"auth\"])                      # (sin prefix aquí)\n\n# ─────────────────────────── SIGN-UP ────────────────────────────\n@router.post(\n    \"/signup\",\n    response_model=UserOut,\n    status_code=status.HTTP_201_CREATED,\n)\n@limiter.limit(\"5/minute\")                             # 🆕 rate-limit\ndef signup(\n    request: Request,               # 👈 obligatorio para slowapi\n    user_in: UserCreate,\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Registra un nuevo usuario.\n\n    • 409 si el **username** o el **email** ya existen.\n    \"\"\"\n    try:\n        return crud.create_user(db, user_in)\n    except IntegrityError:\n        db.rollback()\n        detail = (\n            \"Nombre de usuario en uso\"\n            if crud.get_user_by_username(db, user_in.username)\n            else \"Email ya registrado\"\n        )\n        raise HTTPException(status.HTTP_409_CONFLICT, detail=detail)\n\n\n# ─────────────────────────── LOGIN ──────────────────────────────\n@router.post(\"/token\", response_model=Token)\n@limiter.limit(\"10/minute\")                            # 🆕 rate-limit\ndef login_for_access_token(\n    request: Request,               # 👈 obligatorio\n    form_data: OAuth2PasswordRequestForm = Depends(),\n    db: Session = Depends(get_db),\n):\n    \"\"\"\n    Intercambia usuario/contraseña por un JWT (password grant).\n\n    • 401 si las credenciales no son válidas.\n    \"\"\"\n    user = crud.get_user_by_username(db, form_data.username)\n    if not user or not crud.verify_password(form_data.password, user.hashed_pw):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Usuario o contraseña incorrectos\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    access_token = create_access_token(subject=user.username)\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n\n# ─────────────────────────── WHO AM I? ──────────────────────────\n@router.get(\"/users/me\", response_model=UserOut)\ndef read_users_me(current_user: UserOut = Depends(get_current_user)):\n    \"\"\"Devuelve **id, username y email** asociados al token actual.\"\"\"\n    return current_user\n\n\n# alias corto opcional\nrouter.get(\"/me\", response_model=UserOut)(read_users_me)\n",
    "auth/app/api/__init__.py": "from . import auth, health, password   # re‑export para main.py\n\n__all__ = [\"auth\", \"health\", \"password\"]\n",
    "auth/tests/test_health.py": "def test_health_ok(client):\n    \"\"\"El health‑check debe estar vivo y con la BD operativa.\"\"\"\n    resp = client.get(\"/health\")\n    assert resp.status_code == 200\n    assert resp.json() == {\"ok\": True, \"db\": \"ok\"}\n",
    "auth/tests/test_rate_limit.py": "from app.core.ratelimit import limiter\n\ndef test_rate_limit_on_signup(client):\n    \"\"\"\n    Reactivamos temporalmente el limiter y superamos el umbral 5/min → 429.\n    \"\"\"\n    limiter.enabled = True   # 🔛\n\n    payload = {\n        \"email\":    \"rate@test.com\",\n        \"password\": \"Pass12345\",\n    }\n    # 5 peticiones permitidas\n    for i in range(5):\n        client.post(\"/api/auth/signup\", json={**payload, \"username\": f\"user{i}\"})\n\n    # 6ª → debería saltar el límite\n    r_exceed = client.post(\"/api/auth/signup\", json={**payload, \"username\": \"user_exceed\"})\n    assert r_exceed.status_code == 429\n\n    limiter.enabled = False  # 🔚  para no interferir con otros tests\n",
    "auth/tests/test_auth_flow.py": "from uuid import uuid4\n\n\ndef test_signup_login_me_flow(client):\n    \"\"\"Flujo feliz: alta → login → /me.\"\"\"\n    # 1️⃣  Alta de usuario\n    uname = f\"user_{uuid4().hex[:8]}\"\n    payload = {\n        \"username\": uname,\n        \"email\": f\"{uname}@example.com\",\n        \"password\": \"SuperPass123\",\n    }\n    r_signup = client.post(\"/api/auth/signup\", json=payload)\n    assert r_signup.status_code == 201\n\n    # 2️⃣  Alta duplicada → 409\n    r_dup = client.post(\"/api/auth/signup\", json=payload)\n    assert r_dup.status_code == 409\n\n    # 3️⃣  Login OK\n    r_token = client.post(\n        \"/api/auth/token\",\n        data={\"username\": uname, \"password\": payload[\"password\"]},\n    )\n    assert r_token.status_code == 200\n    token = r_token.json()[\"access_token\"]\n\n    # 4️⃣  /me con Bearer\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    r_me = client.get(\"/api/auth/me\", headers=headers)\n    assert r_me.status_code == 200\n    me = r_me.json()\n    assert me[\"username\"] == uname\n    assert me[\"email\"] == payload[\"email\"]\n\n    # 5️⃣  Login con pass incorrecto → 401\n    r_bad = client.post(\n        \"/api/auth/token\",\n        data={\"username\": uname, \"password\": \"wrong\"},\n    )\n    assert r_bad.status_code == 401\n",
    "auth/tests/conftest.py": "\"\"\"\nFixtures globales para los tests del micro‑servicio Auth\n– BD SQLite in‑memory compartida\n– Override de get_db\n– TestClient\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Generator\n\n# ────── variables de entorno (antes de importar la app) ──────\nos.environ[\"DATABASE_URL\"] = \"sqlite+pysqlite:///:memory:\"\nos.environ.setdefault(\"SECRET_KEY\", \"TEST_SECRET\")\n\n# ────── añadir services/auth al PYTHONPATH del runner ──────\nPROJECT_ROOT = Path(__file__).resolve().parents[2]          # rental-mvp-micro/\nAUTH_PATH = PROJECT_ROOT / \"services\" / \"auth\"\nsys.path.insert(0, str(AUTH_PATH)) if str(AUTH_PATH) not in sys.path else None\n\n# ────── imports de la app (ya con env preparado) ──────\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool                     #  ⭐️\n\nfrom app.main import app\nfrom app.deps import get_db\nfrom app.core.ratelimit import limiter\nfrom app.models.database import Base\n\n# ────── motor y sesión para la BD de pruebas ──────\nengine = create_engine(\n    os.environ[\"DATABASE_URL\"],\n    connect_args={\"check_same_thread\": False},\n    poolclass=StaticPool,            #  👈 comparte la misma conexión\n)\nTestingSessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)\n\nBase.metadata.create_all(bind=engine)       # crea todas las tablas una vez\n\n\ndef override_get_db() -> Generator:\n    db = TestingSessionLocal()\n    try:\n        yield db\n        db.commit()\n    finally:\n        db.close()\n\n\n# sustituimos la dependencia real por la de pruebas\napp.dependency_overrides[get_db] = override_get_db\nlimiter.enabled = False        # sin límites en los tests excepto cuando se active explícitamente\n\n\n# ────── cliente de prueba para cada test ──────\n@pytest.fixture()\ndef client() -> Generator[TestClient, None, None]:\n    with TestClient(app) as c:\n        yield c\n",
    "auth/tests/test_password_flow.py": "from uuid import uuid4\n\ndef test_password_reset_flow(client):\n    \"\"\"Genera reset_token, restablece contraseña y verifica login.\"\"\"\n    # 1️⃣  Alta\n    uname = f\"user_{uuid4().hex[:8]}\"\n    client.post(\n        \"/api/auth/signup\",\n        json={\"username\": uname, \"email\": f\"{uname}@mail.com\", \"password\": \"OldPass123\"},\n    )\n\n    # 2️⃣  Obtener reset_token\n    r_forgot = client.post(\"/api/auth/password/forgot\", json={\"username\": uname})\n    assert r_forgot.status_code == 200\n    reset_token = r_forgot.json()[\"reset_token\"]\n\n    # 3️⃣  Reset OK\n    r_reset = client.post(\n        \"/api/auth/password/reset\",\n        json={\"token\": reset_token, \"new_password\": \"NewPass456\"},\n    )\n    assert r_reset.status_code == 204\n\n    # 4️⃣  Login con nueva contraseña\n    r_login_new = client.post(\n        \"/api/auth/token\",\n        data={\"username\": uname, \"password\": \"NewPass456\"},\n    )\n    assert r_login_new.status_code == 200\n\n    # 5️⃣  Login con contraseña antigua debe fallar\n    r_login_old = client.post(\n        \"/api/auth/token\",\n        data={\"username\": uname, \"password\": \"OldPass123\"},\n    )\n    assert r_login_old.status_code == 401\n"
}